package template;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Random;

import logist.agent.Agent;
import logist.behavior.ReactiveBehavior;
import logist.plan.Action;
import logist.plan.Action.Move;
import logist.plan.Action.Pickup;
import logist.simulation.Vehicle;
import logist.task.Task;
import logist.task.TaskDistribution;
import logist.topology.Topology;
import logist.topology.Topology.City;

public class ReactiveTemplate implements ReactiveBehavior {


	/**
	 * TODO:
	 * comment calculer reward
	 * check quand city vers elle meme
	 * peut pas prendre tache si sup a weight
	 * un agent = plusieurs voitures !!! : rajouter un state par costPerKm
	 * tenir compte de capacity-weight 
	 */

	////////////////////////////////////////////////////////
	//													  //
	//					GLOBAL VARIABLES				  //
	//													  //
	////////////////////////////////////////////////////////

	private Random random;
	private double pPickup;

	private int numberOfCities;
	private int numberOfStates;
	private int numberOfActions;
	private ArrayList<Integer>[] S;
	private HashMap<Integer,Double>[] R;
	private double[][][] T;
	private double[] V;
	private int[] Best;
	private Double discount;
	private List<City> cities;


	////////////////////////////////////////////////////////
	//													  //
	//						SETUP						  //
	//													  //
	////////////////////////////////////////////////////////

	@Override
	public void setup(Topology topology, TaskDistribution td, Agent agent) {

		initVars(topology, agent);

		initS(td);
		print(S);

		initR(td, agent);
		print(R);

		initT(td);


		/*
		initV();

		valueIteration();
		 */
	}

	////////////////////////////////////////////////////////
	//													  //
	//						ACTIONS						  //
	//													  //
	////////////////////////////////////////////////////////

	@Override
	public Action act(Vehicle vehicle, Task availableTask) {
		Action action;

		if (availableTask == null || random.nextDouble() > pPickup) {
			City currentCity = vehicle.getCurrentCity();
			action = new Move(currentCity.randomNeighbor(random));
		} else {
			action = new Pickup(availableTask);
		}
		return action;
	}

	////////////////////////////////////////////////////////
	//													  //
	//					SETUP METHODS					  //
	//													  //
	////////////////////////////////////////////////////////

	private void initVars(Topology topology, Agent agent) {
		// Reads the discount factor from the agents.xml file.
		// If the property is not present it defaults to 0.95
		discount = agent.readProperty("discount-factor", Double.class,
				0.95);
		this.random = new Random();
		this.pPickup = discount;

		numberOfCities = topology.size();
		numberOfStates =  numberOfCities * (numberOfCities);
		numberOfActions = numberOfCities+1;

		cities = topology.cities();
	}

	private void initS(TaskDistribution td) {
		S = (ArrayList<Integer>[]) new ArrayList[numberOfStates];

		for(int s = 0; s<numberOfStates; s++) {
			S[s] = new ArrayList<Integer>();			

			City from = cities.get(indexCityFrom(s));
			City to = cities.get(indexCityTo(s));

			for(City neighbor : from) {
				S[s].add(neighbor.id); // id of the city on which to move
			}

			// if to==from, cannot do the 'pick up' action in this state
			if(to!=from) { 
				S[s].add(numberOfCities); // id of the 'pick up' action
			}
		}
	}

	private void initR(TaskDistribution td, Agent agent) {
		R = (HashMap<Integer,Double>[]) new HashMap[numberOfStates];

		for(int s = 0; s<numberOfStates; s++) {
			R[s] = new HashMap<Integer,Double>();

			City from = cities.get(indexCityFrom(s));
			City to = cities.get(indexCityTo(s));


			for(City neighbor : from) {
				R[s].put(neighbor.id, -from.distanceTo(neighbor)*agent.vehicles().get(0).costPerKm()); // id of the city on which to move
			}

			// if to==from, cannot do the 'pick up' action in this state
			if(to!=from) { 
				// TODO :
				double reward = td.reward(from, to) - from.distanceTo(to)*agent.vehicles().get(0).costPerKm();
				R[s].put(numberOfCities, reward);
			}
		}
	}

	private void initT(TaskDistribution td) {
		T = new double[numberOfStates][numberOfActions][numberOfStates]; // all init to zeros
		for(int s = 0; s<numberOfStates; s++) {
			City to = cities.get(indexCityTo(s));
			for(int action : S[s]) {
				City dest = to;
				if (action!=numberOfCities) dest = cities.get(action);
				for(int c = 0; c<numberOfCities; c++) {
					int newState = c*numberOfCities+dest.id;
					if(c!=dest.id) T[s][action][newState] = td.probability(dest, cities.get(c));
					else T[s][action][newState] = td.probability(dest, null);
				}
			}
		}
	}

	private void initV() {

	}

	private void initStructures(Topology topology, Agent agent) {
		// Reads the discount factor from the agents.xml file.
		// If the property is not present it defaults to 0.95
		discount = agent.readProperty("discount-factor", Double.class,
				0.95);
		this.random = new Random();
		this.pPickup = discount;

		// Init structures :

		numberOfCities = topology.size();
		numberOfStates =  numberOfCities * (numberOfCities+1);
		numberOfActions = numberOfCities+1;
		S = (ArrayList<Integer>[]) new ArrayList[numberOfStates];
		R = (HashMap<Integer,Double>[]) new HashMap[numberOfStates];
		T = new double[numberOfStates][numberOfActions][numberOfStates]; // all init to zeros
		V = new double[numberOfStates];
		Best = new int[numberOfStates];

		cities = topology.cities();
	}

	private void fillStructures(Topology topology, TaskDistribution td) {
		for(int s = 0; s<numberOfStates; s++) {
			S[s] = new ArrayList<Integer>();
			R[s] = new HashMap<Integer,Double>();


			List<City> cities = topology.cities();
			City from = cities.get(indexCityFrom(s));
			City to = null;
			if(s<numberOfCities*numberOfCities) to = cities.get(indexCityTo(s));

			for(City neighbor : from) {
				S[s].add(neighbor.id); // id of the city on which to move
				R[s].put(neighbor.id, -from.distanceTo(neighbor));

				double probaNoTask = 1.0;
				for(int sp = neighbor.id; sp<numberOfStates; sp+=numberOfCities) {
					if(sp<numberOfCities*numberOfCities) { 
						City toto = cities.get(indexCityTo(sp));
						double proba = td.probability(neighbor, toto);
						probaNoTask *= (1-proba);
						T[s][neighbor.id][sp] = proba;
					}
					else {
						T[s][neighbor.id][sp] = probaNoTask; // FALSE : mettre null
					}
				}
			}

			// if to==null, cannot do the 'pick up' action in this state
			if(to!=null) { 
				S[s].add(numberOfCities); // id of the 'pick up' action

				double reward = td.reward(from, to); // ????
				R[s].put(numberOfCities, reward);
			}
		}
	}

	private void valueIteration() {
		boolean again = true;
		while(again) {
			again = false;
			for(int s = 0; s<S.length; s++) {
				double Q, maxQ=0; // ???
				int bestAction = 0;
				for(int a : S[s]) {
					Q = R[s].get(a);
					for(int sp = 0; sp<numberOfStates; sp++) { // optimiser
						Q += discount*T[s][a][sp]*V[sp];
					}
					if(Q>maxQ) {
						maxQ = Q;
						bestAction = a;
					}
				}
				if(Math.abs(V[s]-maxQ)>0.1) again = true;
				V[s] = maxQ;
				Best[s] = bestAction;
			}
		}

		print("Terminated");
	}


	////////////////////////////////////////////////////////
	//													  //
	//						UTILS						  //
	//													  //
	////////////////////////////////////////////////////////

	private void print(String s) {
		System.out.println(s);
	}

	private void print(ArrayList<Integer>[] S) {
		for (int c=0; c<cities.size(); c++) {

			System.out.println(cities.get(c).name + " : " + cities.get(c).id + " : " + c);
		}
		System.out.println("Number of cities = " + numberOfCities);
		System.out.println("Number of actions = " + numberOfActions);
		System.out.println("STATE ARRAY ; length=" + numberOfStates);

		for (int s=0; s<S.length; s++) {
			System.out.print("S=" + s + "; from=" + indexCityFrom(s) + ", to=" + indexCityTo(s) + "; a=");
			for (int a : S[s]) {
				System.out.print(a + ",");
			}
			System.out.println("");
		}
	}

	private void print(HashMap<Integer,Double>[] R) {
		System.out.println("REWARD ARRAY :");
		for (int r=0; r<R.length; r++) {
			System.out.print("S=" + r + "; from=" + indexCityFrom(r) + ", to=" + indexCityTo(r) + "; ");
			for (int a : S[r]) {
				System.out.print("(a=" + a + ", r=" + R[r].get(a) + "); ");
			}
			System.out.println("");
		}
	}
	
	private void print(double[][][] T) {
		System.out.println("T ARRAY :");
		for (int s=0; s<numberOfStates; s++) {
			System.out.println("State = " + s);
			for (int a=0; a<numberOfActions; a++) {
				System.out.print("action=" + a + " S=");
				for (int sp=0; sp<numberOfStates; sp++) {
					System.out.print("(" + sp + "," + T[s][a][sp] + ")");
				}
			}
			System.out.println("");
		}
	}


	private int indexCityFrom(int state) {
		return state%numberOfCities;
	}

	private int indexCityTo(int state) {
		return state/numberOfCities;
	}
}
