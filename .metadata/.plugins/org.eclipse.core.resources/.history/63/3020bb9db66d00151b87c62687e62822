package template;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Random;

import logist.agent.Agent;
import logist.behavior.ReactiveBehavior;
import logist.plan.Action;
import logist.plan.Action.Move;
import logist.plan.Action.Pickup;
import logist.simulation.Vehicle;
import logist.task.Task;
import logist.task.TaskDistribution;
import logist.topology.Topology;
import logist.topology.Topology.City;

public class ReactiveTemplate implements ReactiveBehavior {
	
 
	/**
	 * TODO:
	 * comment calculer reward
	 * check quand city vers elle meme
	 */
	
	////////////////////////////////////////////////////////
	//													  //
	//					GLOBAL VARIABLES				  //
	//													  //
	////////////////////////////////////////////////////////
	
	private Random random;
	private double pPickup;
	
	private int numberOfCities;
	private int numberOfStates;
	private int numberOfActions;
	private ArrayList<Integer>[] S;
	private HashMap<Integer,Double>[] R;
	private double[][][] T;
	private double[] V;
	private int[] Best;
	private Double discount;
	private List<City> cities;
	
	
	////////////////////////////////////////////////////////
	//													  //
	//						SETUP						  //
	//													  //
	////////////////////////////////////////////////////////

	@Override
	public void setup(Topology topology, TaskDistribution td, Agent agent) {

		initVars();
		initS();
		initR();
		initT();
		initV();
		
		fillStructures(topology, td);
		
		valueIteration();
	}
	
	////////////////////////////////////////////////////////
	//													  //
	//						ACTIONS						  //
	//													  //
	////////////////////////////////////////////////////////

	@Override
	public Action act(Vehicle vehicle, Task availableTask) {
		Action action;

		if (availableTask == null || random.nextDouble() > pPickup) {
			City currentCity = vehicle.getCurrentCity();
			action = new Move(currentCity.randomNeighbor(random));
		} else {
			action = new Pickup(availableTask);
		}
		return action;
	}
	
	////////////////////////////////////////////////////////
	//													  //
	//					SETUP METHODS					  //
	//													  //
	////////////////////////////////////////////////////////
	
	private void initVars() {
		// Reads the discount factor from the agents.xml file.
		// If the property is not present it defaults to 0.95
		discount = agent.readProperty("discount-factor", Double.class,
				0.95);
		this.random = new Random();
		this.pPickup = discount;
		
		// Init structures :
		
		numberOfCities = topology.size();
		numberOfStates =  numberOfCities * (numberOfCities+1);
		numberOfActions = numberOfCities+1;
	}
	
	private void initS() {
		S = (ArrayList<Integer>[]) new ArrayList[numberOfStates];
		
		for(int s = 0; s<numberOfStates; s++) {
			S[s] = new ArrayList<Integer>();
			R[s] = new HashMap<Integer,Double>();
			
			
			List<City> cities = topology.cities();
			City from = cities.get(indexCityFrom(s));
			City to = null;
			if(s<numberOfCities*numberOfCities) to = cities.get(indexCityTo(s));
			
			for(City neighbor : from) {
				S[s].add(neighbor.id); // id of the city on which to move
				R[s].put(neighbor.id, -from.distanceTo(neighbor));
				
				double probaNoTask = 1.0;
				for(int sp = neighbor.id; sp<numberOfStates; sp+=numberOfCities) {
					if(sp<numberOfCities*numberOfCities) { 
						City toto = cities.get(indexCityTo(sp));
						double proba = td.probability(neighbor, toto);
						probaNoTask *= (1-proba);
						T[s][neighbor.id][sp] = proba;
					}
					else {
						T[s][neighbor.id][sp] = probaNoTask;
					}
				}
			}
			
			// if to==null, cannot do the 'pick up' action in this state
			if(to!=null) { 
				S[s].add(numberOfCities); // id of the 'pick up' action
				
				double reward = td.reward(from, to); // ????
				R[s].put(numberOfCities, reward);
			}
		}
	}
	
	private void initR() {
		
	}
	
	private void initT() {
		
	}
	
	private void initV() {
		
	}
	
	private void initStructures(Topology topology, Agent agent) {
		// Reads the discount factor from the agents.xml file.
		// If the property is not present it defaults to 0.95
		discount = agent.readProperty("discount-factor", Double.class,
				0.95);
		this.random = new Random();
		this.pPickup = discount;
		
		// Init structures :
		
		numberOfCities = topology.size();
		numberOfStates =  numberOfCities * (numberOfCities+1);
		numberOfActions = numberOfCities+1;
		S = (ArrayList<Integer>[]) new ArrayList[numberOfStates];
		R = (HashMap<Integer,Double>[]) new HashMap[numberOfStates];
		T = new double[numberOfStates][numberOfActions][numberOfStates]; // all init to zeros
		V = new double[numberOfStates];
		Best = new int[numberOfStates];
		
		cities = topology.cities();
	}
	
	private void fillStructures(Topology topology, TaskDistribution td) {
		for(int s = 0; s<numberOfStates; s++) {
			S[s] = new ArrayList<Integer>();
			R[s] = new HashMap<Integer,Double>();
			
			
			List<City> cities = topology.cities();
			City from = cities.get(indexCityFrom(s));
			City to = null;
			if(s<numberOfCities*numberOfCities) to = cities.get(indexCityTo(s));
			
			for(City neighbor : from) {
				S[s].add(neighbor.id); // id of the city on which to move
				R[s].put(neighbor.id, -from.distanceTo(neighbor));
				
				double probaNoTask = 1.0;
				for(int sp = neighbor.id; sp<numberOfStates; sp+=numberOfCities) {
					if(sp<numberOfCities*numberOfCities) { 
						City toto = cities.get(indexCityTo(sp));
						double proba = td.probability(neighbor, toto);
						probaNoTask *= (1-proba);
						T[s][neighbor.id][sp] = proba;
					}
					else {
						T[s][neighbor.id][sp] = probaNoTask;
					}
				}
			}
			
			// if to==null, cannot do the 'pick up' action in this state
			if(to!=null) { 
				S[s].add(numberOfCities); // id of the 'pick up' action
				
				double reward = td.reward(from, to); // ????
				R[s].put(numberOfCities, reward);
			}
		}
	}
	
	private void valueIteration() {
		boolean again = true;
		while(again) {
			again = false;
			for(int s = 0; s<S.length; s++) {
				double Q, maxQ=0; // ???
				int bestAction = 0;
				for(int a : S[s]) {
					Q = R[s].get(a);
					for(int sp = 0; sp<numberOfStates; sp++) { // optimiser
						Q += discount*T[s][a][sp]*V[sp];
					}
					if(Q>maxQ) {
						maxQ = Q;
						bestAction = a;
					}
				}
				if(Math.abs(V[s]-maxQ)>0.1) again = true;
				V[s] = maxQ;
				Best[s] = bestAction;
			}
		}
		
		print("Terminated");
	}
	
	
	////////////////////////////////////////////////////////
	//													  //
	//						UTILS						  //
	//													  //
	////////////////////////////////////////////////////////
	
	private void print(String s) {
		System.out.println(s);
	}
	
	private int indexCityFrom(int state) {
		return state%numberOfCities;
	}
	
	private int indexCityTo(int state) {
		return state/numberOfCities;
	}
}
